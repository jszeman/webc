<!DOCTYPE html>
<head>
    <style>
        table, td, th {
            border: 1px solid black;
            border-collapse: collapse;
        }

        td, th {
            padding: 4px;
        }

    </style>
    <script>
        class Bitfield extends HTMLElement {

            constructor()
            {
                super();
                this.fields = [];
            }

            render(bits, value, header)
            {
                let th = header.split(',');
                if (th.length < 2)
                {
                    th = ['Bit', 'Value'];
                }

                let html_str = `
                    <table>
                        <tr>
                            <th>${th[0].trim()}</th>
                            <th>${th[1].trim()}</th>
                        </tr>`;

                this.fields = [];
                let idx = 0;

                

                for (const bit of bits.split(','))
                {
                    const row = bit.trim().split(':');
                    const name = row[0];
                    const len = Number(row[1]) ? Number(row[1]) : 1;
                    this.fields.push(len)
                    const mask = (2**len-1) << idx;
                    const bit_value = (value & mask) >> idx;
                    idx += len;

                    html_str += `<tr><td>${name}</td><td>${bit_value}</td></tr>`
                }

                html_str += '</table>'

                this.innerHTML = html_str;

                this.tbody = this.querySelector('table tbody')
            }

            connectedCallback()
            {
                const value = Number(this.attributes.value.value);
                const bits = this.attributes.bits.value;
                const header = this.hasAttribute('header') ? this.attributes.header.value: 'Bit, Value';

                this.render(bits, value, header);
            }

            static get observedAttributes()
            {
                return ['value', 'bits'];
            }

            update_value(value)
            {
                let shift = 0;
                for (const [i, len] of this.fields.entries())
                {
                    const mask = (2**len-1) << shift;
                    const bit_value = (value & mask) >> shift;
                    shift += len;
                    this.tbody.children[i+1].children[1].textContent = bit_value;
                }
            }
            
            attributeChangedCallback(attrName, oldValue, newValue)
            {
                console.log(attrName);
                if (newValue !== oldValue) {
                    if (attrName == 'value')
                    {
                        this.update_value(newValue);
                    }
                    else if (attrName == 'bits')
                    {
                        const value = Number(this.attributes.value.value);
                        const header = this.hasAttribute('header') ? this.attributes.header.value: 'Bit, Value';
                        this.render(newValue, value, header);
                    }
                }
            }
        }

        window.customElements.define('pwtk-bitfield', Bitfield);
    </script>
</head>
<html>
    <body>
        <h1>Web component testing ground</h1>
        <pwtk-bitfield id='bf-id' bits='A, B, C, D, E, F:3' header='Name, Value' value='0x55'></pwtk-bitfield>
    </body>
</html>